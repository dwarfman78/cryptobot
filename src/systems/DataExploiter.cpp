//
// Created by dwarf on 17/07/2021.
//

#include "../../include/systems/DataExploiter.hpp"
void DataExploiter::configure(entityx::EntityManager &es, entityx::EventManager &events)
{
    mDirectoryName = "dataexploiter";

    mChai.add(chaiscript::fun(&DataExploiter::parseData,this),"parseData");

    mChai.add_global(chaiscript::var(&mCumulDeltaT),"mCumulDeltaT");

    mChai.add_global(chaiscript::var(&mIteration),"mIteration");

    mChai.add(chaiscript::var(&mCalculateLinearRegression),"mCalculateLinearRegression");

    mChai.add(chaiscript::fun(&Data::refreshTick),"refreshTick");

    mChai.add(chaiscript::fun(&Utils::to_string),"to_string");

    mChai.add(chaiscript::bootstrap::standard_library::map_type<std::map<std::string, std::string> >("ConfigMap"));
    mChai.add(chaiscript::var(&Utils::config), "config");
    mChai.eval_file("scripts/config.chai");

    events.subscribe<FilterByKeywordClickedEvent>(*this);
    events.subscribe<FilterByRegexpEnteredEvent>(*this);
    events.subscribe<CalculateLinearRegressionEvent>(*this);
    events.subscribe<CalculateMinMaxEvent>(*this);


    ScriptedSystem::configure(es,events);

}
void DataExploiter::receive(const CalculateMinMaxEvent& guiEvent)
{
    mCalculateMinMax = guiEvent.value;
}
void DataExploiter::receive(const CalculateLinearRegressionEvent& guiEvent)
{
    mCalculateLinearRegression = guiEvent.value;
}
void DataExploiter::receive(const FilterByKeywordClickedEvent& guiEvent)
{
    mFilterByKeyWord = guiEvent.value;
}
void DataExploiter::receive(const FilterByRegexpEnteredEvent& guiEvent)
{
    mFilterByRegexp = guiEvent.value;
}
bool DataExploiter::shouldRun(entityx::EntityManager& es, entityx::EventManager& events, entityx::TimeDelta dt)
{
    bool returnValue{false};
    es.each<Data>([&](entityx::Entity entity, Data& data) {
        returnValue = returnValue || data.refreshTick > mCumulDeltaT;
    });
    return returnValue;
}
bool DataExploiter::parseKeywords(const std::string& keyWordJson, Json::Value& keyWordJsonValue) const
{
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();

    std::string errors;

    bool parsingSuccessful = reader->parse(
            keyWordJson.c_str(),
            keyWordJson.c_str() + keyWordJson.size(),
            &keyWordJsonValue,
            &errors
    );
    if(reader!=nullptr)
    {
        delete reader;
        reader = nullptr;
    }

    return parsingSuccessful;
}
void DataExploiter::parseData(Data& pData) const
{
    std::lock_guard<std::mutex> guard(*pData.lock);

    parseBinanceData(pData);
    parseGeckoData(pData);
}
void DataExploiter::parseGeckoData(Data& pData) const
{
    if(!pData.geckoTrending.empty())
    {
        if(parseKeywords(pData.geckoTrending, pData.geckoTrendingJson))
        {
            auto coins = pData.geckoTrendingJson["coins"];
            pData.trendingTokens.clear();

            for(int i=0; i < coins.size(); i++)
            {
                pData.trendingTokens.insert({coins[i]["item"]["score"].as<unsigned int>(),coins[i]["item"]["symbol"].as<std::string>()});
            }
        }
    }
}
void DataExploiter::parseBinanceData(Data& pData) const
{
    Json::Value &json = pData.binanceTokenPrice;

    auto &history = pData.byTokenName;

    for (int i = 0; i < json.size(); i++)
    {
        std::string symbol = json[i].get("symbol", "DEFAULT").asString();

        double price = std::stod(json[i].get("price", "0.0f").asString());

        if (std::regex_match(symbol, std::regex(Utils::config["regexptokenfilter"])))
        {
            auto &historyList = history[symbol];

            historyList.push_back({mIteration, price});

            std::string tokenWithoutAgainst = symbol;
            Utils::eraseSubstring(tokenWithoutAgainst, Utils::config["tradingagainst"]);

            if (Utils::isTokenSelected(mFilterByRegexp,mFilterByKeyWord,tokenWithoutAgainst,pData.trendingTokens))
            {
                unsigned int histoSize = historyList.size();

                movingAverage(pData,symbol,10);
                calculateHiLows(pData,symbol);
                detectTrendingChanges(pData,symbol);

                if(mCalculateLinearRegression)
                {
                    std::vector<double> xVectorLow, yVectorLow;
                    Utils::splitDataInTwoVectors(pData.lowsByTokenName[symbol],xVectorLow,yVectorLow,0,pData.lowsByTokenName[symbol].size());
                    pData.lowsLinearRegression[symbol].push_back(linearRegression(symbol,xVectorLow,yVectorLow));
                    
                    std::vector<double> xVectorHi, yVectorHi;
                    Utils::splitDataInTwoVectors(pData.hisByTokenName[symbol],xVectorHi,yVectorHi,0,pData.hisByTokenName[symbol].size());
                    pData.hisLinearRegression[symbol].push_back(linearRegression(symbol,xVectorHi,yVectorHi));
                    

                    std::vector<double> xVector, yVector;
                    Utils::splitDataInTwoVectors(historyList,xVector,yVector,0,histoSize);
                    pData.linearRegressionByTokenName[symbol].push_back(linearRegression(symbol,xVector,yVector));
                }

                if(mCalculateMinMax)
                {
                    auto& supportMaxHistory = pData.supportMaxByTokenName[symbol];

                    supportMaxHistory.push_back(support(historyList,[](auto &&begin, auto &&end) { return std::max_element(begin, end); }));

                    auto& supportMinHistory = pData.supportMinByTokenName[symbol];

                    supportMinHistory.push_back(support(historyList,[](auto &&begin, auto &&end) { return std::min_element(begin, end); }));
                }
            }
        }
    }
}
void DataExploiter::detectTrendingChanges(Data& pData, const std::string& symbol) const
{
    
    auto& his = pData.hisByTokenName[symbol];
    if(his.size()>=2)
    {
        auto& lastHi = his.back();
        auto& hiBeforeLast = *(his.end()-2);

        if(lastHi.first-hiBeforeLast.first>10 && lastHi.second<hiBeforeLast.second)
        {

            auto& lows = pData.hisByTokenName[symbol];
            if(lows.size()>=2)
            {
                auto& lastLow = lows.back();
                auto& lowBeforeLast = *(lows.end()-2);

                if(lastLow.first-lowBeforeLast.first>10 && lastLow.second<lowBeforeLast.second)
                {
                    double mark = lastHi.first<lastLow.first ? lastLow.first : lastHi.first;
                    double markValue = lastHi.first<lastLow.first ? lastLow.second : lastHi.second;

                    pData.trendingChangeByTokenName[symbol].push_back({mark,markValue});
                }
            }
        }
    }

    
}
void DataExploiter::movingAverage(Data& pData,const std::string& symbol, unsigned int movingAverageSize) const
{
    auto& historyList = pData.byTokenName[symbol];
    unsigned int numberOfValues = historyList.size();
    if(numberOfValues >= movingAverageSize)
    {
        unsigned int begin = numberOfValues-movingAverageSize;
        unsigned int end = numberOfValues;
        double sum = 0.0;
        auto& currentTokenMovingAverage = pData.movingAverageByTokenName[symbol];

        for(int i = begin; i<end; i++)
        {
            sum+=historyList[i].second;
        }
        currentTokenMovingAverage.push_back({numberOfValues-movingAverageSize/2.0,(sum/(movingAverageSize))*1.0});
    }
}

template <typename TF>
std::pair<double,double> DataExploiter::support(const std::vector<std::pair<double,double>>& pData, TF&& func) const
{
    std::pair<double,double> retour{0.0,0.0};

    std::vector<double> vectorY;
    vectorY.resize(pData.size());
    std::transform(pData.begin(),pData.end(),vectorY.begin(),[](std::pair<double,double> p)->double{return p.second;});

    auto elt = func(vectorY.begin(),vectorY.end());

    if(elt!=vectorY.end()) {
        unsigned int pos1 = std::distance(vectorY.begin(), elt);
        double maxValue1 = *elt;

        vectorY.erase(elt);

        elt = func(vectorY.begin(), vectorY.end());
        if(elt!=vectorY.end()) {

            double maxValue2 = *elt;

            unsigned int pos2 = std::distance(vectorY.begin(), elt);

            while (maxValue1 == maxValue2 && vectorY.size() > 2) {
                if (elt != vectorY.end()) {
                    vectorY.erase(elt);
                    elt = func(vectorY.begin(), vectorY.end());
                    maxValue2 = *elt;

                    pos2 = std::distance(vectorY.begin(), elt);
                }
            }

            if(pos1 == pos2)
                pos2++;

            double a = (maxValue1 - maxValue2) / (pos1 - pos2);
            double b = maxValue2 - a * pos2;
            retour = {a, b};
        }
    }

    return retour;

}

double DataExploiter::moyenne(const std::vector<double>& values) const
{
    if(values.size()>0) {
        double sum{std::accumulate(values.begin(), values.end(), 0.0)};
        return sum / values.size();
    } else
    {
        return 0.0;
    }
}
void DataExploiter::calculateHiLows(Data& pData, const std::string& symbol) const
{
    auto& history = pData.byTokenName[symbol];
    unsigned int histoSize = history.size();
    if(histoSize>20)
    {
        std::vector<double> xVectorA, yVectorA, xVectorB, yVectorB;
        Utils::splitDataInTwoVectors(history,xVectorA,yVectorA,histoSize-20,10);
        Utils::splitDataInTwoVectors(history,xVectorB,yVectorB,histoSize-10,10);

        auto&& lineA = linearRegression(symbol,xVectorA,yVectorA);
        auto&& lineB = linearRegression(symbol,xVectorB,yVectorB);

        if(lineA.first>0&&lineB.first<0)
        {
            pData.hisByTokenName[symbol].push_back(history[histoSize-10]);
        }
        if(lineA.first<0&&lineB.first>0)
        {
            pData.lowsByTokenName[symbol].push_back(history[histoSize-10]);
        }
    }
}

std::pair<double,double> DataExploiter::linearRegression(const std::string& symbol, std::vector<double>& xVector, std::vector<double>& yVector) const {

    double xbarre = moyenne(xVector);
    double ybarre = moyenne(yVector);

    std::transform(xVector.begin(),xVector.end(),xVector.begin(),[xbarre](double x) -> double {return x - xbarre;});
    std::transform(yVector.begin(),yVector.end(),yVector.begin(),[ybarre](double y) -> double {return y - ybarre;});

    std::vector<double> XxbYyb;
    XxbYyb.resize(xVector.size());

    std::transform(xVector.begin(),xVector.end(),yVector.begin(),XxbYyb.begin(),std::multiplies<double>());

    std::transform(xVector.begin(),xVector.end(),xVector.begin(),[](double xMoinsXb) -> double { return xMoinsXb * xMoinsXb;});

    double sommeXxbYyb{std::accumulate(XxbYyb.begin(),XxbYyb.end(),0.0)};
    double sommeXxbCarre{std::accumulate(xVector.begin(),xVector.end(),0.0)};

    double a = sommeXxbYyb/sommeXxbCarre;
    double b = ybarre - a * xbarre;

    return {a,b};
}
