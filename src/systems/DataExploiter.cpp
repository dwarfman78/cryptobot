//
// Created by dwarf on 17/07/2021.
//

#include "../../include/systems/DataExploiter.hpp"
void DataExploiter::configure(entityx::EntityManager &es, entityx::EventManager &events)
{
    mDirectoryName = "dataexploiter";

    ScriptedSystem::configure(es,events);

    mChai.add(chaiscript::fun(&DataExploiter::parseData,this),"parseData");

    mChai.add_global(chaiscript::var(&mCumulDeltaT),"mCumulDeltaT");

    mChai.add_global(chaiscript::var(&mIteration),"mIteration");

    mChai.add(chaiscript::fun(&Data::refreshTick),"refreshTick");

    mChai.add(chaiscript::fun(&Utils::to_string),"to_string");

    mChai.add(chaiscript::bootstrap::standard_library::map_type<std::map<std::string, std::string> >("ConfigMap"));
    mChai.add(chaiscript::var(&Utils::config), "config");
    mChai.eval_file("scripts/config.chai");

    events.subscribe<FilterByKeywordClickedEvent>(*this);
    events.subscribe<FilterByRegexpEnteredEvent>(*this);
    events.subscribe<CalculateLinearRegressionEvent>(*this);
    events.subscribe<CalculateMinMaxEvent>(*this);

}
void DataExploiter::receive(const CalculateMinMaxEvent& guiEvent)
{
    mCalculateMinMax = guiEvent.value;
}
void DataExploiter::receive(const CalculateLinearRegressionEvent& guiEvent)
{
    mCalculateLinearRegression = guiEvent.value;
}
void DataExploiter::receive(const FilterByKeywordClickedEvent& guiEvent)
{
    mFilterByKeyWord = guiEvent.value;
}
void DataExploiter::receive(const FilterByRegexpEnteredEvent& guiEvent)
{
    mFilterByRegexp = guiEvent.value;
}
bool DataExploiter::shouldRun(entityx::EntityManager& es, entityx::EventManager& events, entityx::TimeDelta dt)
{
    bool returnValue{false};
    es.each<Data>([&](entityx::Entity entity, Data& data) {
        returnValue = returnValue || data.refreshTick > mCumulDeltaT;
    });
    return returnValue;
}
bool DataExploiter::parseKeywords(const std::string& keyWordJson, Json::Value& keyWordJsonValue) const
{
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();

    std::string errors;

    bool parsingSuccessful = reader->parse(
            keyWordJson.c_str(),
            keyWordJson.c_str() + keyWordJson.size(),
            &keyWordJsonValue,
            &errors
    );
    delete reader;

    return parsingSuccessful;
}
void DataExploiter::parseData(Data& pData) const
{
    std::lock_guard<std::mutex> guard(*pData.lock);

    parseBinanceData(pData);
    parseGeckoData(pData);
}
void DataExploiter::parseGeckoData(Data& pData) const
{
    if(!pData.geckoTrending.empty())
    {
        if(parseKeywords(pData.geckoTrending, pData.geckoTrendingJson))
        {
            auto coins = pData.geckoTrendingJson["coins"];
            pData.trendingTokens.clear();

            for(int i=0; i < coins.size(); i++)
            {
                pData.trendingTokens.insert({coins[i]["item"]["score"].as<unsigned int>(),coins[i]["item"]["symbol"].as<std::string>()});
            }
        }
    }
}
void DataExploiter::parseBinanceData(Data& pData) const
{

    Json::Value &json = pData.binanceTokenPrice;

    auto &history = pData.byTokenName;

    for (int i = 0; i < json.size(); i++)
    {
        std::string symbol = json[i].get("symbol", "DEFAULT").asString();

        double price = std::stod(json[i].get("price", "0.0f").asString());

        if (std::regex_match(symbol, std::regex(Utils::config["regexptokenfilter"])))
        {
            auto &historyList = history[symbol];

            historyList.push_back({mIteration, price});

            std::string tokenWithoutAgainst = symbol;
            Utils::eraseSubstring(tokenWithoutAgainst, Utils::config["tradingagainst"]);

            if (Utils::isTokenSelected(mFilterByRegexp,mFilterByKeyWord,tokenWithoutAgainst,pData.trendingTokens))
            {
                unsigned int movingAverageSize = 10;
                unsigned int numberOfValues = historyList.size();
                if(numberOfValues >= movingAverageSize)
                {
                    unsigned int begin = numberOfValues-movingAverageSize;
                    unsigned int end = numberOfValues;
                    double sum = 0.0;
                    auto& currentTokenMovingAverage = pData.movingAverageByTokenName[symbol];

                    for(int i = begin; i<end; i++)
                    {
                        sum+=historyList[i].second;
                    }
                    currentTokenMovingAverage.push_back({numberOfValues-movingAverageSize/2.0,(sum/(movingAverageSize))*1.0});
                }

                if(mCalculateLinearRegression)
                {
                    auto &linearRegressionHistory = pData.linearRegressionByTokenName[symbol];

                    linearRegressionHistory.push_back(linearRegression(historyList));
                }

                if(mCalculateMinMax)
                {
                    auto &supportMaxHistory = pData.supportMaxByTokenName[symbol];

                    supportMaxHistory.push_back(support(historyList,[](auto &&begin, auto &&end) { return std::max_element(begin, end); }));

                    auto &supportMinHistory = pData.supportMinByTokenName[symbol];

                    supportMinHistory.push_back(support(historyList,[](auto &&begin, auto &&end) { return std::min_element(begin, end); }));
                }
            }
        }
    }
}

template <typename TF>
std::pair<double,double> DataExploiter::support(const std::vector<std::pair<double,double>>& pData, TF&& func) const
{
    std::pair<double,double> retour{0.0,0.0};

    std::vector<double> vectorY;
    vectorY.resize(pData.size());
    std::transform(pData.begin(),pData.end(),vectorY.begin(),[](std::pair<double,double> p)->double{return p.second;});

    auto elt = func(vectorY.begin(),vectorY.end());

    if(elt!=vectorY.end()) {
        unsigned int pos1 = std::distance(vectorY.begin(), elt);
        double maxValue1 = *elt;

        vectorY.erase(elt);

        elt = func(vectorY.begin(), vectorY.end());
        if(elt!=vectorY.end()) {

            double maxValue2 = *elt;

            unsigned int pos2 = std::distance(vectorY.begin(), elt);

            while (maxValue1 == maxValue2 && vectorY.size() > 2) {
                if (elt != vectorY.end()) {
                    vectorY.erase(elt);
                    elt = func(vectorY.begin(), vectorY.end());
                    maxValue2 = *elt;

                    pos2 = std::distance(vectorY.begin(), elt);
                }
            }

            if(pos1 == pos2)
                pos2++;

            double a = (maxValue1 - maxValue2) / (pos1 - pos2);
            double b = maxValue2 - a * pos2;
            retour = {a, b};
        }
    }

    return retour;

}

double DataExploiter::moyenne(const std::vector<double>& values) const
{
    if(values.size()>0) {
        double sum{std::accumulate(values.begin(), values.end(), 0.0)};
        return sum / values.size();
    } else
    {
        return 0;
    }
}

std::pair<double, double> DataExploiter::linearRegression(const std::vector<std::pair<double, double>> &pData) const {

    std::vector<double> xVector,yVector;
    xVector.resize(pData.size());
    yVector.resize(pData.size());

    std::transform(pData.begin(),pData.end(),xVector.begin(),[](std::pair<double,double>pair)->double{return pair.first;});
    std::transform(pData.begin(),pData.end(),yVector.begin(),[](std::pair<double,double>pair)->double{return pair.second;});

    double xbarre = moyenne(xVector);
    double ybarre = moyenne(yVector);

    std::transform(xVector.begin(),xVector.end(),xVector.begin(),[xbarre](double x) -> double {return x - xbarre;});
    std::transform(yVector.begin(),yVector.end(),yVector.begin(),[ybarre](double y) -> double {return y - ybarre;});

    std::vector<double> XxbYyb;
    XxbYyb.resize(xVector.size());

    std::transform(xVector.begin(),xVector.end(),yVector.begin(),XxbYyb.begin(),std::multiplies<double>());

    std::transform(xVector.begin(),xVector.end(),xVector.begin(),[](double xMoinsXb) -> double { return xMoinsXb * xMoinsXb;});

    double sommeXxbYyb{std::accumulate(XxbYyb.begin(),XxbYyb.end(),0.0)};
    double sommeXxbCarre{std::accumulate(xVector.begin(),xVector.end(),0.0)};

    double a = sommeXxbYyb/sommeXxbCarre;
    double b = ybarre - a * xbarre;

    return {a,b};

}
