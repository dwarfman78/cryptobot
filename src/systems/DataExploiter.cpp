//
// Created by dwarf on 17/07/2021.
//
#include "../../include/systems/DataExploiter.hpp"
void DataExploiter::configure(entityx::EntityManager &es, entityx::EventManager &events)
{
    mDirectoryName = "dataexploiter";

    ScriptedSystem::configure(es,events);

    mChai.add(chaiscript::fun(&DataExploiter::parseData,this),"parseData");

    mChai.add_global(chaiscript::var(&mCumulDeltaT),"mCumulDeltaT");

    mChai.add_global(chaiscript::var(&mIteration),"mIteration");

    mChai.add(chaiscript::fun(&Data::refreshTick),"refreshTick");

    mChai.add(chaiscript::fun(&Utils::to_string),"to_string");

    mChai.add(chaiscript::bootstrap::standard_library::map_type<std::map<std::string, std::string> >("ConfigMap"));
    mChai.add(chaiscript::var(&Utils::config), "config");
    mChai.eval_file("scripts/config.chai");

    events.subscribe<FilterByKeywordClickedEvent>(*this);
    events.subscribe<FilterByRegexpEnteredEvent>(*this);

}
void DataExploiter::receive(const FilterByKeywordClickedEvent& guiEvent)
{
    mFilterByKeyWord = guiEvent.value;
}
void DataExploiter::receive(const FilterByRegexpEnteredEvent& guiEvent)
{
    mFilterByRegexp = guiEvent.value;
}
bool DataExploiter::shouldRun(entityx::EntityManager& es, entityx::EventManager& events, entityx::TimeDelta dt)
{
    bool returnValue{false};
    es.each<Data>([&](entityx::Entity entity, Data& data) {
        returnValue = returnValue || data.refreshTick > mCumulDeltaT;
    });
    return returnValue;
}
bool DataExploiter::parseKeywords(const std::string& keyWordJson, Json::Value& keyWordJsonValue) const
{
    Json::CharReaderBuilder builder;
    Json::CharReader* reader = builder.newCharReader();

    std::string errors;

    bool parsingSuccessful = reader->parse(
            keyWordJson.c_str(),
            keyWordJson.c_str() + keyWordJson.size(),
            &keyWordJsonValue,
            &errors
    );
    delete reader;

    return parsingSuccessful;
}
void DataExploiter::parseData(Data& pData) const
{
    std::lock_guard<std::mutex> guard(*pData.lock);

    parseBinanceData(pData);
    parseGeckoData(pData);
}
void DataExploiter::parseGeckoData(Data& pData) const
{
    if(!pData.geckoTrending.empty())
    {
        if(parseKeywords(pData.geckoTrending, pData.geckoTrendingJson))
        {
            auto coins = pData.geckoTrendingJson["coins"];
            pData.trendingTokens.clear();

            for(int i=0; i < coins.size(); i++)
            {
                pData.trendingTokens.insert({coins[i]["item"]["score"].as<unsigned int>(),coins[i]["item"]["symbol"].as<std::string>()});
            }
        }
    }
}
void DataExploiter::parseBinanceData(Data& pData) const
{

    Json::Value &json = pData.binanceTokenPrice;

    auto &history = pData.byTokenName;
    int calculated = 0;
    for (int i = 0; i < json.size(); i++)
    {
        std::string symbol = json[i].get("symbol", "DEFAULT").asString();

        double price = std::stod(json[i].get("price", "0.0f").asString());

        if (std::regex_match(symbol, std::regex(Utils::config["regexptokenfilter"])))
        {
            auto &historyList = history[symbol];

            historyList.push_back({mIteration, price});

            //std::cout << " pushing back : " << symbol << " price : " << price << std::endl;

            std::string tokenWithoutAgainst = symbol;
            Utils::eraseSubstring(tokenWithoutAgainst, Utils::config["tradingagainst"]);

            if (Utils::isTokenSelected(mFilterByRegexp,mFilterByKeyWord,tokenWithoutAgainst,pData.trendingTokens))
            {
                calculated++;
                auto &linearRegressionHistory = pData.linearRegressionByTokenName[symbol];

                linearRegressionHistory.push_back(linearRegression(historyList));

                auto &supportMaxHistory = pData.supportMaxByTokenName[symbol];

                //std::cout << "support max" << std::endl;

                supportMaxHistory.push_back(
                        support(historyList, [](auto &&begin, auto &&end) { return std::max_element(begin, end); }));

                auto &supportMinHistory = pData.supportMinByTokenName[symbol];

                //std::cout << "support min" << std::endl;

                supportMinHistory.push_back(
                        support(historyList, [](auto &&begin, auto &&end) { return std::min_element(begin, end); }));
            }
        }
    }
    std::cout << "Calculated : " << calculated << std::endl;
}

template <typename TF>
std::pair<double,double> DataExploiter::support(const std::vector<std::pair<double,double>>& pData, TF&& func) const
{
    //std::cout << "\t Support ..." << std::endl;

    std::pair<double,double> retour{0.0,0.0};

    std::vector<double> vectorY;
    vectorY.resize(pData.size());
    std::transform(pData.begin(),pData.end(),vectorY.begin(),[](std::pair<double,double> p)->double{return p.second;});

    auto maxElt = func(vectorY.begin(),vectorY.end());

    if(maxElt!=vectorY.end()) {
        unsigned int pos1 = std::distance(vectorY.begin(), maxElt);
        double maxValue1 = *maxElt;

        //std::cout << "\t\t Value1 : " << maxValue1 << std::endl;

        vectorY.erase(maxElt);

        maxElt = func(vectorY.begin(), vectorY.end());
        if(maxElt!=vectorY.end()) {

            double maxValue2 = *maxElt;
            //std::cout << "\t\t Value2 : " << maxValue2 << std::endl;

            unsigned int pos2 = std::distance(vectorY.begin(), maxElt);

            while (maxValue1 == maxValue2 && vectorY.size() > 2) {
                if (maxElt != vectorY.end()) {
                    vectorY.erase(maxElt);
                    maxElt = func(vectorY.begin(), vectorY.end());
                    maxValue2 = *maxElt;

                    pos2 = std::distance(vectorY.begin(), maxElt);
                }
            }

            if(pos1 == pos2)
                pos2++;

            double a = (maxValue1 - maxValue2) / (pos1 - pos2);
            double b = maxValue2 - a * pos2;
            retour = {a, b};
        }
    }

    return retour;

}

double DataExploiter::moyenne(const std::vector<double>& values) const
{
    if(values.size()>0) {
        double sum{std::accumulate(values.begin(), values.end(), 0.0)};
        return sum / values.size();
    } else
    {
        return 0;
    }
}

std::pair<double, double> DataExploiter::linearRegression(const std::vector<std::pair<double, double>> &pData) const {

    //std::cout << "\t linear regression " << std::endl;
    std::vector<double> xVector,yVector;
    xVector.resize(pData.size());
    yVector.resize(pData.size());

    std::transform(pData.begin(),pData.end(),xVector.begin(),[](std::pair<double,double>pair)->double{return pair.first;});
    std::transform(pData.begin(),pData.end(),yVector.begin(),[](std::pair<double,double>pair)->double{return pair.second;});

    double xbarre = moyenne(xVector);
    double ybarre = moyenne(yVector);

    std::transform(xVector.begin(),xVector.end(),xVector.begin(),[xbarre](double x) -> double {return x - xbarre;});
    std::transform(yVector.begin(),yVector.end(),yVector.begin(),[ybarre](double y) -> double {return y - ybarre;});

    std::vector<double> XxbYyb;
    XxbYyb.resize(xVector.size());

    std::transform(xVector.begin(),xVector.end(),yVector.begin(),XxbYyb.begin(),std::multiplies<double>());

    std::transform(xVector.begin(),xVector.end(),xVector.begin(),[](double xMoinsXb) -> double { return xMoinsXb * xMoinsXb;});

    double sommeXxbYyb{std::accumulate(XxbYyb.begin(),XxbYyb.end(),0.0)};
    double sommeXxbCarre{std::accumulate(xVector.begin(),xVector.end(),0.0)};

    double a = sommeXxbYyb/sommeXxbCarre;
    double b = ybarre - a * xbarre;

    //std::cout << "\t fin linear regression" << std::endl;
    return {a,b};

}
